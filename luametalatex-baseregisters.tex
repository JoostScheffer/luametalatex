\begingroup
\catcode`\^^^^ffff=11
\catcode`\@=11
\toks0{%
  do
  local function frozen(s)
    local t = token.create(s)
    return token.new(t.mode, t.command)
  end
  local dimen_cmd = token.command_id'assign_dimen'
  local count_cmd = token.command_id'assign_int'
  local toks_cmd = token.command_id'assign_toks'
  local tex_params = {}
  local texmeta = getmetatable(tex)
  local texmetaoldindex = texmeta.__index
  local texmetaoldnewindex = texmeta.__newindex
  function texmeta.__index(t, k)
    local v = tex_params[k]
    if v then
      if v.command == count_cmd then
        return tex.count[v.index]
      elseif v.command == dimen_cmd then
        return tex.dimen[v.index]
      elseif v.command == toks_cmd then
        return tex.toks[v.index]
      end
    else
      return texmetaoldindex(t, k)
    end
  end
  function texmeta.__newindex(t, k, v)
    local p = tex_params[k]
    if p then
      if p.command == count_cmd then
        tex.count[p.index] = v
      elseif p.command == dimen_cmd then
        tex.dimen[p.index] = v
      elseif p.command == toks_cmd then
        tex.toks[p.index] = v
      end
    else
      return texmetaoldnewindex(t, k, v)
    end
  end
  local pdf_params = {}
  pdf.variable_tokens = pdf_params
  pdf.variable = setmetatable({}, {
    __index = function(t, k)
      local v = pdf_params[k]
      if v then
        if v.command == count_cmd then
          return tex.count[v.index]
        elseif v.command == dimen_cmd then
          return tex.dimen[v.index]
        elseif v.command == toks_cmd then
          return tex.toks[v.index]
        end
      else
        return texmetaoldindex(t, k)
      end
    end,
    __newindex = function(t, k, v)
      local p = pdf_params[k]
      if p then
        if p.command == count_cmd then
          tex.count[p.index] = v
        elseif p.command == dimen_cmd then
          tex.dimen[p.index] = v
        elseif p.command == toks_cmd then
          tex.toks[p.index] = v
        end
      else
        return texmetaoldnewindex(t, k, v)
      end
    end,
  })
}
\def\InternalAlloc#1#2#3#4#5{%
  \csname new#3\endcsname#1%
  \global#1=#5\relax
  \etoksapp0{#2_params["\luaescapestring{#4}"] = frozen"\luaescapestring{\csstring#1}"}
}
\def\internalAlloc#1#2#3{%
  \expandafter\InternalAlloc\csname ^^^^fffe#3@#1\endcsname{#1}{#2}{#3}%
}
\def\texAlloc#1#2{%
  \expandafter\InternalAlloc\csname #2\endcsname{tex}{#1}{#2}%
}
\def\pdfAlloc{%
  \internalAlloc{pdf}%
}
\texAlloc{count}{suppressfontnotfounderror}{0}
\texAlloc{count}{outputmode}{1} % The "traditional" default would be 0,
                                % but we do not actually support that.
\texAlloc{dimen}{pageheight}{297mm}
\texAlloc{dimen}{pagewidth}{210mm}
\pdfAlloc{dimen}{horigin}{1in}
\pdfAlloc{dimen}{vorigin}{1in}
\pdfAlloc{dimen}{linkmargin}{0pt}
\pdfAlloc{count}{majorversion}{1}
\pdfAlloc{count}{minorversion}{7}
\pdfAlloc{count}{compresslevel}{0} % 0 is actually the only supported value right now, so this is basically ignored
\pdfAlloc{count}{objcompresslevel}{0} % see above
\pdfAlloc{toks}{pageresources}{{}}

\texAlloc{count}{bodydirection}{0}
\texAlloc{count}{pagedirection}{0}
\etoksapp0{
  function tex.getbodydir() return tex.bodydirection end
  function tex.getpagedir() return tex.pagedirection end
  function tex.setbodydir(i) tex.bodydirection = i end
  function tex.setpagedir(i) tex.pagedirection = i end
  local dir_regs = require 'luametalatex-dir-registers'
  dir_regs 'textdir'
  dir_regs 'bodydir'
  dir_regs 'pagedir'
  end
}

\directlua{
  lua.prepared_code[\csstring#lua.prepared_code+1] = tex.toks[0]
  \the\toks0
}
\endgroup
